/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/clamp/index.js":
/*!*************************************!*\
  !*** ./node_modules/clamp/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n\n\n//# sourceURL=webpack:///./node_modules/clamp/index.js?");

/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = __webpack_require__(/*! color-name */ \"./node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack:///./node_modules/color-convert/conversions.js?");

/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/color-convert/conversions.js\");\nconst route = __webpack_require__(/*! ./route */ \"./node_modules/color-convert/route.js\");\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack:///./node_modules/color-convert/index.js?");

/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const conversions = __webpack_require__(/*! ./conversions */ \"./node_modules/color-convert/conversions.js\");\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/color-convert/route.js?");

/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/color-name/index.js?");

/***/ }),

/***/ "./node_modules/lerp/index.js":
/*!************************************!*\
  !*** ./node_modules/lerp/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function lerp(v0, v1, t) {\n    return v0*(1-t)+v1*t\n}\nmodule.exports = lerp\n\n//# sourceURL=webpack:///./node_modules/lerp/index.js?");

/***/ }),

/***/ "./src/Color.js":
/*!**********************!*\
  !*** ./src/Color.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Color; });\nconst colorConvert = __webpack_require__(/*! color-convert */ \"./node_modules/color-convert/index.js\");\nMath.clamp = __webpack_require__(/*! clamp */ \"./node_modules/clamp/index.js\");\nMath.lerp = __webpack_require__(/*! lerp */ \"./node_modules/lerp/index.js\");\n\nclass Color {\n  constructor(color) {\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    this.a = 1;\n    if (color == null) {\n      color = {};\n    }\n    let colorType = \"rgb255\";\n    if (color.type != null) {\n      colorType = color.type;\n    }\n\n    if (color.type == \"rgb255\") {\n      this.r = Math.clamp(color.r / 255, 0, 1);\n      this.g = Math.clamp(color.g / 255, 0, 1);\n      this.b = Math.clamp(color.b / 255, 0, 1);\n      if (color.a != null) {\n        this.a = Math.clamp(color.a / 255, 0, 1);\n      } else {\n        this.a = 1;\n      }\n    } else if (color.type == \"rgb01\") {\n      this.r = Math.clamp(color.r, 0, 1);\n      this.g = Math.clamp(color.g, 0, 1);\n      this.b = Math.clamp(color.b, 0, 1);\n      if (color.a != null) {\n        this.a = Math.clamp(color.a, 0, 1);\n      } else {\n        this.a = 1;\n      }\n    } else if (color.type == \"hex\") {\n      // TODO: Write my own implementation to handle alpha\n      let rgb255Color = colorConvert.hex.rgb(color.hex);\n      this.r = rgb255Color[0] / 255;\n      this.g = rgb255Color[1] / 255;\n      this.b = rgb255Color[2] / 255;\n    } else if (color.type == \"hsv\") {\n      let newColor = colorConvert.hsv.rgb([color.h, color.s, color.v]);\n      this.r = newColor[0] / 255;\n      this.g = newColor[1] / 255;\n      this.b = newColor[2] / 255;\n    } else if (color.type == \"hsl\") {\n      let newColor = colorConvert.hsl.rgb([color.h, color.s, color.l]);\n      this.r = newColor[0] / 255;\n      this.g = newColor[1] / 255;\n      this.b = newColor[2] / 255;\n    } else if (color.type == \"lch\") {\n      let newColor = colorConvert.lch.rgb([color.l, color.c, color.h]);\n      this.r = newColor[0] / 255;\n      this.g = newColor[1] / 255;\n      this.b = newColor[2] / 255;\n    }\n\n    Object.freeze(this);\n  }\n\n  getRGB255() {\n    return [\n      Math.clamp(Math.floor(this.r * 256), 0, 255),\n      Math.clamp(Math.floor(this.g * 256), 0, 255),\n      Math.clamp(Math.floor(this.b * 256), 0, 255),\n      Math.clamp(Math.floor(this.a * 256), 0, 255),\n    ];\n  }\n\n  getRGB01() {\n    return [\n      this.r, this.g, this.b, this.a\n    ];\n  }\n\n  getHex() {\n    return colorConvert.rgb.hex(...this.getRGB255());\n  }\n\n  getHSV() {\n    return colorConvert.rgb.hsv(...this.getRGB255());\n  }\n\n  getHSL() {\n    return colorConvert.rgb.hsl(...this.getRGB255());\n  }\n\n  getLCH() {\n    return colorConvert.rgb.lch(...this.getRGB255());\n  }\n\n  toCSS() {\n    return `rgba(${this.getRGB255().join(\", \")})`;\n  }\n\n  static fromRGB255Array(arr) {\n    return new Color({\n      type: \"rgb255\",\n      r: arr[0],\n      g: arr[1],\n      b: arr[2]\n    });\n  }\n\n  static lerp(color0, color1, t, mode = \"rgb\") {\n    if (mode === \"rgb\") {\n      return new Color({\n        type: \"rgb01\",\n        r: Math.lerp(color0.r, color1.r, t),\n        g: Math.lerp(color0.g, color1.g, t),\n        b: Math.lerp(color0.b, color1.b, t),\n        a: Math.lerp(color0.a, color1.a, t)\n      });\n    } else if (mode === \"hsv\") {\n      let hsv0 = color0.getHSV();\n      let hsv1 = color1.getHSV();\n      return new Color({\n        type: \"hsv\",\n        h: Math.lerp(hsv0[0], hsv1[0], t),\n        s: Math.lerp(hsv0[1], hsv1[1], t),\n        v: Math.lerp(hsv0[2], hsv1[2], t)\n      });\n    } else if (mode === \"hsl\") {\n      let hsl0 = color0.getHSL();\n      let hsl1 = color1.getHSL();\n      return new Color({\n        type: \"hsl\",\n        h: Math.lerp(hsl0[0], hsl1[0], t),\n        s: Math.lerp(hsl0[1], hsl1[1], t),\n        l: Math.lerp(hsl0[2], hsl1[2], t)\n      });\n    } else if (mode == \"lch\") {\n      let lch0 = color0.getLCH();\n      let lch1 = color1.getLCH();\n      return new Color({\n        type: \"lch\",\n        l: Math.lerp(lch0[0], lch1[0], t),\n        c: Math.lerp(lch0[1], lch1[1], t),\n        h: Math.lerp(lch0[2], lch1[2], t)\n      });\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./src/Color.js?");

/***/ }),

/***/ "./src/ColorGradient.js":
/*!******************************!*\
  !*** ./src/ColorGradient.js ***!
  \******************************/
/*! exports provided: ColorGradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorGradient\", function() { return ColorGradient; });\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color.js */ \"./src/Color.js\");\n\n\nclass ColorGradient {\n    constructor(divElement, divInterpMode = \"rgb\") {\n        this.colors = [];\n        this.positions = [];\n\n        this.divElement = divElement;\n        this.divInterpMode = divInterpMode;\n\n        this.addColorStop(0, new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            type: \"rgb01\",\n            r: 1,\n            g: 0,\n            b: 0\n        }));\n        this.addColorStop(1, new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            type: \"rgb01\",\n            r: 1,\n            g: 1,\n            b: 1\n        }));\n\n        this.update();\n    }\n\n    setColorStop(position, color) {\n        let index = this.positions.indexOf(position);\n        if (index == -1) {\n            this.addColorStop(position, color);\n        } else {\n            this.colors[index] = color;\n        }\n        this.update();\n    }\n\n    addColorStop(position, color) {\n        this.colors.push(color);\n        this.positions.push(position);\n    }\n\n    getColorAt(position, mode = this.divInterpMode) {\n        if (this.colors.length === 0) {\n            return new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0, 0);\n        }\n        if (this.colors.length === 1) {\n            return this.colors[0];\n        }\n\n        let i = 0;\n        while (i < this.positions.length && position > this.positions[i]) {\n            i++;\n        }\n\n        if (i === 0) {\n            return this.colors[0];\n        }\n        if (i === this.positions.length) {\n            return this.colors[this.colors.length - 1];\n        }\n\n        const p0 = this.positions[i - 1];\n        const p1 = this.positions[i];\n        const c0 = this.colors[i - 1];\n        const c1 = this.colors[i];\n\n        const t = (position - p0) / (p1 - p0);\n\n        return _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lerp(c0, c1, t, mode = mode);\n    }\n\n    update() {\n        let gradient = \"linear-gradient(to right\";\n        for (let i = 0; i < 100; i++) {\n            gradient += \", \" + this.getColorAt(i / 100).toCSS() + \" \" + i + \"%\";\n        }\n        gradient += \")\";\n\n        // console.log(gradient);\n        this.divElement.style.backgroundImage = gradient;\n    }\n}\n\n//# sourceURL=webpack:///./src/ColorGradient.js?");

/***/ }),

/***/ "./src/ColorPicker.js":
/*!****************************!*\
  !*** ./src/ColorPicker.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ColorPicker; });\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color.js */ \"./src/Color.js\");\n/* harmony import */ var _ColorGradient_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorGradient.js */ \"./src/ColorGradient.js\");\n\n\nMath.clamp = __webpack_require__(/*! clamp */ \"./node_modules/clamp/index.js\");\n\nclass ColorPicker {\n  constructor() {\n    this.imageInput = document.getElementById(\"image-input\");\n    this.hexInput = document.getElementById(\"hex-input\");\n    this.rgb255Input = document.getElementById(\"rgb255-input\");\n    this.rgb01Input = document.getElementById(\"rgb01-input\");\n    this.hsvInput = document.getElementById(\"hsv-input\");\n    this.documentBody = document.getElementById(\"doc-body\");\n    this.coordinatesContainer = document.getElementById(\n      \"coordinates-container\"\n    );\n    this.imagePreviewCanvas = document.getElementById(\"image-preview-canvas\");\n    this.imagePreviewOverlayCanvas = document.getElementById(\"image-preview-overlay-canvas\");\n    this.imagePreviewOverlayColorInputs = document.querySelectorAll('input[name=\"image-preview-overlay-color\"]');\n    this.colorBar = document.getElementById(\"color-bar\");\n    this.colorGrad = document.getElementById(\"color-grad-1\");\n    this.colorGrad2 = document.getElementById(\"color-grad-2\");\n    this.colorGradCircle = document.getElementById(\"color-grad-circle\");\n    this.colorBarPointer = document.getElementById(\"color-bar-pointer\");\n    this.colorBarPointer3 = document.getElementById(\"color-bar-pointer3\");\n    this.colorBarPointer4 = document.getElementById(\"color-bar-pointer4\");\n    this.colorGradHue = 0;\n    this.colorGradSaturation = 0;\n    this.colorGradValue = 100;\n    this.updateColorGrad();\n\n    this.colorInterpDiv = document.querySelector(\".color-interp-div\");\n    this.colorInterpGradients = [];\n    if (this.colorInterpDiv) {\n      this.colorInterpLeft = document.querySelector(\".color-interp-left-color\");\n      this.colorInterpRight = document.querySelector(\".color-interp-right-color\");\n      this.colorInterpGradientRGB = new _ColorGradient_js__WEBPACK_IMPORTED_MODULE_1__[\"ColorGradient\"](\n        this.colorInterpDiv.querySelector(\".color-interp-gradient-rgb\"),\n        \"rgb\"\n      );\n      this.colorInterpGradientHSL = new _ColorGradient_js__WEBPACK_IMPORTED_MODULE_1__[\"ColorGradient\"](\n        this.colorInterpDiv.querySelector(\".color-interp-gradient-hsl\"),\n        \"hsl\"\n      );\n      this.colorInterpGradientLCH = new _ColorGradient_js__WEBPACK_IMPORTED_MODULE_1__[\"ColorGradient\"](\n        this.colorInterpDiv.querySelector(\".color-interp-gradient-lch\"),\n        \"lch\"\n      );\n\n      this.colorInterpGradients = [\n        this.colorInterpGradientRGB,\n        this.colorInterpGradientHSL,\n        this.colorInterpGradientLCH\n      ];\n    }\n  }\n\n  setColor(newColor, options = {}) {\n    if (!options.silent) {\n      console.log(\"Changing color to\", newColor);\n    }\n    if (this.rgb255Input && !options.ignoreRGB255) {\n      this.rgb255Input.value = newColor\n        .getRGB255()\n        .splice(0, 3)\n        .toString();\n    }\n    if (this.rgb01Input && !options.ignoreRGB01) {\n      this.rgb01Input.value = newColor\n        .getRGB01()\n        .splice(0, 3)\n        .map(x => x.toFixed(3))\n        .toString();\n    }\n    if (this.hexInput && !options.ignoreHex) {\n      this.hexInput.value = \"#\" + newColor.getHex();\n    }\n    if (this.hsvInput && !options.ignoreHSV) {\n      this.hsvInput.value = newColor.getHSV().toString();\n    }\n    if (this.documentBody) {\n      this.documentBody.style.background = \"#\" + newColor.getHex();\n    }\n    if (this.coordinatesContainer && !options.keepCoordinates) {\n      this.coordinatesContainer.innerHTML = \"(0, 0)<br>(0, 0)\";\n    }\n    if (options.updateColorGrad || options.updateColorGrad == null) {\n      this.updateColorGrad(newColor, { setColor: false });\n    }\n    if (this.colorInterpDiv && !options.ignoreInterp) {\n      this.updateColorInterp(newColor);\n    }\n  }\n\n  attachListeners() {\n    const imageInput = this.imageInput;\n    const hexInput = this.hexInput;\n    const rgb255Input = this.rgb255Input;\n    const rgb01Input = this.rgb01Input;\n    const hsvInput = this.hsvInput;\n    const coordinatesContainer = this.coordinatesContainer;\n    const imagePreviewCanvas = this.imagePreviewCanvas;\n    const imagePreviewOverlayCanvas = this.imagePreviewOverlayCanvas;\n    const colorBar = this.colorBar;\n    const colorGrad2 = this.colorGrad2;\n\n    if (imageInput) {\n      imageInput.addEventListener(\"change\", () => {\n        if (imageInput.files.length !== 1) {\n          return;\n        }\n        let image = imageInput.files[0];\n        let reader = new FileReader();\n        let img = new Image();\n        img.onload = function () {\n          if (imagePreviewCanvas) {\n            imagePreviewCanvas.width = img.width;\n            imagePreviewCanvas.height = img.height;\n            let ctx = imagePreviewCanvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            if (imagePreviewOverlayCanvas) {\n              imagePreviewOverlayCanvas.width = img.width;\n              imagePreviewOverlayCanvas.height = img.height;\n            }\n          }\n        };\n        reader.onload = function (e) {\n          img.src = e.target.result;\n        };\n        reader.readAsDataURL(image);\n      });\n    }\n\n    if (imagePreviewOverlayCanvas) {\n      imagePreviewOverlayCanvas.addEventListener(\"mousemove\", e => {\n        const mousedown = (e.buttons && e.buttons | 1) || e.which === 1;\n        if (!mousedown) return;\n        let mousePos = {\n          x: e.offsetX / imagePreviewOverlayCanvas.clientWidth,\n          y: e.offsetY / imagePreviewOverlayCanvas.clientHeight\n        };\n        let intCoordinates = {\n          x: Math.clamp(\n            Math.floor(\n              mousePos.x * imagePreviewOverlayCanvas.width,\n              0,\n              imagePreviewOverlayCanvas.width - 1\n            )\n          ),\n          y: Math.clamp(\n            Math.floor(\n              mousePos.y * imagePreviewOverlayCanvas.height,\n              0,\n              imagePreviewOverlayCanvas.height - 1\n            )\n          )\n        };\n        this.updateFromImageOverlay(intCoordinates);\n      });\n      imagePreviewOverlayCanvas.addEventListener(\"click\", e => {\n        const mousedown = (e.buttons && e.buttons | 1) || e.which === 1;\n        if (!mousedown) return;\n        let mousePos = {\n          x: e.offsetX / imagePreviewOverlayCanvas.clientWidth,\n          y: e.offsetY / imagePreviewOverlayCanvas.clientHeight\n        };\n        let intCoordinates = {\n          x: Math.clamp(\n            Math.floor(\n              mousePos.x * imagePreviewOverlayCanvas.width,\n              0,\n              imagePreviewOverlayCanvas.width - 1\n            )\n          ),\n          y: Math.clamp(\n            Math.floor(\n              mousePos.y * imagePreviewOverlayCanvas.height,\n              0,\n              imagePreviewOverlayCanvas.height - 1\n            )\n          )\n        };\n        this.updateFromImageOverlay(intCoordinates);\n      });\n\n      if (this.colorInterpDiv) {\n        this.colorInterpLeft.addEventListener(\"click\", () => {\n          this.colorInterpLeft.classList.toggle(\"active\");\n          this.colorInterpRight.classList.remove(\"active\");\n          this.setColor(this.colorInterpGradientRGB.getColorAt(0), { ignoreInterp: true });\n        });\n        this.colorInterpRight.addEventListener(\"click\", () => {\n          this.colorInterpRight.classList.toggle(\"active\");\n          this.colorInterpLeft.classList.remove(\"active\");\n          this.setColor(this.colorInterpGradientRGB.getColorAt(1), { ignoreInterp: true });\n        });\n      }\n    }\n\n    if (hexInput) {\n      hexInput.addEventListener(\"input\", () => {\n        const value = hexInput.value;\n        const hexRegex = /^#?([0-9a-zA-Z]{3}(?:[0-9a-zA-Z]{3})?)$/;\n        const match = hexRegex.exec(value);\n        if (match && match.length == 2) {\n          console.log(`Found Hex: ${match[1]}`);\n          let color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            type: \"hex\",\n            hex: match[1]\n          });\n          this.setColor(color, {\n            ignoreHex: true\n          });\n        }\n      });\n    }\n\n    if (rgb255Input) {\n      rgb255Input.addEventListener(\"input\", () => {\n        const value = rgb255Input.value.trim().replace(/\\s/g, \",\");\n        const rgb255Regex = /^(\\d{1,3}),+(\\d{1,3}),+(\\d{1,3})$/;\n        const match = rgb255Regex.exec(value);\n        if (match && match.length == 4) {\n          let newColor = match.slice(1, 4).map(x => parseInt(x));\n          let inRange = newColor\n            .map(x => 0 <= x && x <= 255)\n            .reduce((acc, x) => acc && x);\n          if (inRange) {\n            console.log(`Found RGB255: ${match.slice(1, 4)}`);\n            let color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n              type: \"rgb255\",\n              r: newColor[0],\n              g: newColor[1],\n              b: newColor[2]\n            });\n            this.setColor(color, {\n              ignoreRGB255: true\n            });\n          }\n        }\n      });\n    }\n\n    if (rgb01Input) {\n      rgb01Input.addEventListener(\"input\", () => {\n        const value = rgb01Input.value.trim().replace(/\\s/g, \",\");\n        const rgb01Regex = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?),+([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?),+([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)$/;\n        const match = rgb01Regex.exec(value);\n        if (match && match.length == 4) {\n          let newColor = match.slice(1, 4).map(x => parseFloat(x));\n          let inRange = newColor\n            .map(x => 0 <= x && x <= 1)\n            .reduce((acc, x) => acc && x);\n          if (inRange) {\n            console.log(`Found RGB01: ${newColor.toString()}`);\n            let color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n              type: \"rgb01\",\n              r: newColor[0],\n              g: newColor[1],\n              b: newColor[2]\n            });\n            this.setColor(color, {\n              ignoreRGB01: true\n            });\n          }\n        }\n      });\n    }\n\n    if (hsvInput) {\n      hsvInput.addEventListener(\"input\", () => {\n        const value = hsvInput.value.trim().replace(/\\s/g, \",\");\n        const rgb01Regex = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?),+([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?),+([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)$/;\n        const match = rgb01Regex.exec(value);\n        if (match && match.length == 4) {\n          let newColor = match.slice(1, 4).map(x => parseInt(x));\n          console.log(`Found HSV: ${newColor.toString()}`);\n          let color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            type: \"hsv\",\n            h: Math.clamp(newColor[0], 0, 360),\n            s: Math.clamp(newColor[1], 0, 100),\n            v: Math.clamp(newColor[2], 0, 100)\n          });\n          this.setColor(color, {\n            ignoreHSV: true\n          });\n        }\n      });\n    }\n\n    if (colorBar) {\n      let mousedown = false;\n      colorBar.addEventListener(\"mousedown\", e => {\n        mousedown = true;\n        const bbox = colorBar.getBoundingClientRect();\n        this.colorGradHue =\n          360 *\n          Math.clamp((e.clientX - bbox.left) / colorBar.clientWidth, 0, 1);\n        this.updateColorGrad();\n      });\n      colorBar.addEventListener(\"mousemove\", e => {\n        if (mousedown) {\n          const bbox = colorBar.getBoundingClientRect();\n          this.colorGradHue =\n            360 *\n            Math.clamp((e.clientX - bbox.left) / colorBar.clientWidth, 0, 1);\n          this.updateColorGrad();\n        }\n      });\n      document.addEventListener(\"mouseup\", e => {\n        if (mousedown) {\n          mousedown = false;\n        }\n      });\n    }\n\n    if (colorGrad2) {\n      let mousedown = false;\n      colorGrad2.addEventListener(\"mousedown\", e => {\n        mousedown = true;\n        const bbox = colorGrad2.getBoundingClientRect();\n        this.colorGradSaturation =\n          100 *\n          Math.clamp((e.clientX - bbox.left) / colorGrad2.clientWidth, 0, 1);\n        this.colorGradValue =\n          100 *\n          Math.clamp(\n            1 - (e.clientY - bbox.top) / colorGrad2.clientHeight,\n            0,\n            1\n          );\n        this.updateColorGrad();\n      });\n      colorGrad2.addEventListener(\"mousemove\", e => {\n        if (mousedown) {\n          const bbox = colorGrad2.getBoundingClientRect();\n          this.colorGradSaturation =\n            100 *\n            Math.clamp((e.clientX - bbox.left) / colorGrad2.clientWidth, 0, 1);\n          this.colorGradValue =\n            100 *\n            Math.clamp(\n              1 - (e.clientY - bbox.top) / colorGrad2.clientHeight,\n              0,\n              1\n            );\n          this.updateColorGrad();\n        }\n      });\n      document.addEventListener(\"mouseup\", e => {\n        if (mousedown) {\n          mousedown = false;\n        }\n      });\n    }\n\n    if (this.colorInterpDiv) {\n      this.colorInterpGradients.forEach(x => {\n        x.divElement.addEventListener(\"click\", event => {\n          const positionX = event.offsetX / x.divElement.clientWidth;\n          const newColor = x.getColorAt(positionX);\n          this.setColor(newColor, { ignoreInterp: true });\n          this.colorInterpRight.classList.remove(\"active\");\n          this.colorInterpLeft.classList.remove(\"active\");\n        });\n        x.divElement.addEventListener(\"mousemove\", event => {\n          if (event.buttons == 1) {\n            const positionX = event.offsetX / x.divElement.clientWidth;\n            const newColor = x.getColorAt(positionX);\n            this.setColor(newColor, { ignoreInterp: true });\n            this.colorInterpRight.classList.remove(\"active\");\n            this.colorInterpLeft.classList.remove(\"active\");\n          }\n        });\n      });\n    }\n  }\n\n  updateFromImageOverlay(intCoordinates) {\n    const coordinatesContainer = this.coordinatesContainer;\n    const imagePreviewCanvas = this.imagePreviewCanvas;\n    const imagePreviewOverlayCanvas = this.imagePreviewOverlayCanvas;\n    if (coordinatesContainer) {\n      const floatCoordinates = {\n        x: intCoordinates.x / imagePreviewOverlayCanvas.width,\n        y: intCoordinates.y / imagePreviewOverlayCanvas.height\n      }\n      coordinatesContainer.innerHTML = \"\";\n      coordinatesContainer.appendChild(\n        document.createTextNode(\n          `(${floatCoordinates.x.toFixed(3)}, ${floatCoordinates.y.toFixed(3)})`\n        )\n      );\n      coordinatesContainer.appendChild(document.createElement(\"br\"));\n      coordinatesContainer.appendChild(\n        document.createTextNode(\n          `(${intCoordinates.x}, ${intCoordinates.y})`\n        )\n      );\n    }\n    const ctx = imagePreviewCanvas.getContext(\"2d\");\n    const colors = ctx.getImageData(\n      intCoordinates.x,\n      intCoordinates.y,\n      1, 1);\n    this.setColor(_Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromRGB255Array(colors.data), {\n      keepCoordinates: true\n    });\n\n    const overlayColor = Array.from(this.imagePreviewOverlayColorInputs).filter(x => x.checked)[0].value;\n    const minWidthHeight = Math.min(imagePreviewOverlayCanvas.width, imagePreviewOverlayCanvas.height);\n    const radius = 0.05 * minWidthHeight;\n    const overlayCtx = imagePreviewOverlayCanvas.getContext(\"2d\");\n    overlayCtx.clearRect(0, 0, imagePreviewOverlayCanvas.width, imagePreviewOverlayCanvas.height);\n    overlayCtx.beginPath();\n    overlayCtx.arc(\n      intCoordinates.x,\n      intCoordinates.y,\n      radius, 0, 2 * Math.PI);\n    overlayCtx.strokeStyle = overlayColor;\n    overlayCtx.lineWidth = 0.01 * minWidthHeight;\n    overlayCtx.stroke();\n  }\n\n  updateColorGrad(newColor, options = {}) {\n    const colorGrad = this.colorGrad;\n    let hue, saturation, value;\n    if (newColor == null) {\n      newColor = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        type: \"hsv\",\n        h: this.colorGradHue,\n        s: this.colorGradSaturation,\n        v: this.colorGradValue\n      });\n      [hue, saturation, value] = [\n        this.colorGradHue,\n        this.colorGradSaturation,\n        this.colorGradValue\n      ];\n    } else {\n      [hue, saturation, value] = newColor.getHSV();\n    }\n\n    if (colorGrad) {\n      const color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        type: \"hsv\",\n        h: hue,\n        s: 100,\n        v: 100\n      });\n      const hex = color.getHex();\n      colorGrad.style.background = `linear-gradient(to right, #FFF 0%, #${hex} 100%)`;\n    }\n\n    if (options.setColor == null || options.setColor) {\n      this.setColor(newColor, {\n        silent: true,\n        updateColorGrad: false\n      });\n    }\n\n    if (\n      options.updateColorGradCircle ||\n      options.updateColorGradCircle == null\n    ) {\n      this.updateColorGradCircle(newColor, value, saturation);\n    }\n\n    if (\n      options.updateColorBarPointer ||\n      options.updateColorBarPointer == null\n    ) {\n      this.updateHuePointer(hue);\n    }\n  }\n\n  updateColorGradCircle(newColor, value, saturation) {\n    if (newColor == null) {\n      newColor = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        type: \"hsv\",\n        h: this.colorGradHue,\n        s: this.colorGradSaturation,\n        v: this.colorGradValue\n      });\n    }\n    const colorGrad = this.colorGrad;\n    const colorGradCircle = this.colorGradCircle;\n    if (colorGradCircle) {\n      const totalHeight = colorGrad.clientHeight;\n      const totalWidth = colorGrad.clientWidth;\n      const offset = colorGradCircle.clientWidth / 2;\n      colorGradCircle.style.top =\n        String((1.0 - value / 100) * totalHeight - offset) + \"px\";\n      colorGradCircle.style.left =\n        String((saturation / 100) * totalWidth - offset) + \"px\";\n      colorGradCircle.style.backgroundColor = `#${newColor.getHex()}`;\n      if (value < 50) {\n        colorGradCircle.style.borderColor = \"white\";\n      } else {\n        colorGradCircle.style.borderColor = \"black\";\n      }\n    }\n  }\n\n  updateHuePointer(hue) {\n    const colorBarPointer = this.colorBarPointer;\n    const colorBarPointer3 = this.colorBarPointer3;\n    const colorBarPointer4 = this.colorBarPointer4;\n    if (colorBarPointer) {\n      const color = new _Color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        type: \"hsv\",\n        h: hue,\n        s: 100,\n        v: 100\n      });\n      const newColorHex = `#${color.getHex()}`;\n      colorBarPointer.style.left = (100 * hue) / 360 + \"%\";\n      colorBarPointer3.style.borderBottomColor = newColorHex;\n      colorBarPointer4.style.borderColor = newColorHex;\n    }\n  }\n\n  updateColorInterp(newColor) {\n    if (this.colorInterpDiv) {\n      if (this.colorInterpLeft && this.colorInterpLeft.classList.contains(\"active\")) {\n        this.colorInterpLeft.style.backgroundColor = `#${newColor.getHex()}`;\n        this.colorInterpGradients.forEach(x => x.setColorStop(0, newColor));\n      }\n      if (this.colorInterpRight && this.colorInterpRight.classList.contains(\"active\")) {\n        this.colorInterpRight.style.backgroundColor = `#${newColor.getHex()}`;\n        this.colorInterpGradients.forEach(x => x.setColorStop(1, newColor));\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./src/ColorPicker.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ColorPicker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorPicker.js */ \"./src/ColorPicker.js\");\n\n\nconst colorConvert = __webpack_require__(/*! color-convert */ \"./node_modules/color-convert/index.js\");\nwindow.colorConvert = colorConvert;\n\nconst myColorPicker = new _ColorPicker_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nmyColorPicker.attachListeners();\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });